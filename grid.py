# grid functions go here!

import pygame as pg
import numpy as np
import random
import imageio as io

''' initialise an empty grid (numpy array of binary values) with the described cell size (min 2, max 99) '''
def makeGrid(size):
    # creates an array of the desired size populated with zeros
    grid = np.zeros((size*2 + 1, size*2 + 1), dtype=int)
    
    # implants 1's in the array that correspond to cells
    for i in range(size):
        for j in range(size):
            grid[i*2+1, j*2+1] = 1

    return grid


''' returns a uniform spanning tree maze of the described cell size (min 2, max 99) generated by the Aldous-Broder algorithm '''
def aldousBroder(size):
    # create grid (initially of zeros)
    grid = np.zeros((size*2 + 1, size*2 + 1), dtype=int)

    # pick a random cell
    row = random.randrange(1, len(grid), 2); col = random.randrange(1, len(grid), 2)

    moveOptions = ['l', 'r', 'u', 'd']
    rRestrict = lRestrict = uRestrict = dRestrict = False

    # check movement restrictions of current position, remove from options list accordingly
    if col == 1:
        lRestrict = True
        moveOptions.remove('l')
    elif (col + 2) == len(grid):
        rRestrict = True
        moveOptions.remove('r')
    if row == 1:
        uRestrict = True
        moveOptions.remove('u')
    elif (row + 2) == len(grid):
        dRestrict = True
        moveOptions.remove('d')


    ''' debug algorithm-watching code start'''
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    RED =   (255,   0,   0)

    # initializes the screen with a grid-based resolution 
    screen = pg.display.set_mode(size=(len(grid)*50, len(grid)*50))

    # Clear the screen and set the screen background
    screen.fill(WHITE)
    ''' debug algorithm-watching code end '''


    # while not all squares are connected (and thereby not visited... you start with size*size and carve out that same amount minus 1, so that's the goal)
    # first move (break down wall if there is one), then if restricted in other direction remove this restriction, add back to move list (boolean exists for easy check rather than indexing list over and over)
    # next, check position to ensure whether you need to restrict other direction, and if necessary remove from list
    while (np.count_nonzero(grid) < (2*size*size - 1)):

        print(f"ab moved to ", row, ", ", col)
        # randomly choose a movement direction from available options
        currentMove = random.choice(moveOptions)

        # move, then expand or restrict movement options as is necessary in new position
        # left movement routine
        if currentMove == 'l':
            col -= 2 
            if grid[row, col] != 2:
                grid[row, col] = 2
                grid[row, col + 1] = 1

            if rRestrict:
                rRestrict = False
                moveOptions.append('r')
            if col == 1:
                lRestrict = True
                moveOptions.remove('l')
        # right movement routine
        elif currentMove == 'r':
            col += 2
            if grid[row, col] != 2:
                grid[row, col] = 2
                grid[row, col - 1] = 1

            if lRestrict:
                lRestrict = False
                moveOptions.append('l')
            if (col + 2) == len(grid):
                rRestrict = True
                moveOptions.remove('r')
        # up movement routine
        elif currentMove == 'u':
            row -= 2
            if grid[row, col] != 2:
                grid[row, col] = 2
                grid[row + 1, col] = 1

            if dRestrict:
                dRestrict = False
                moveOptions.append('d')
            if row == 1:
                uRestrict = True
                moveOptions.remove('u')
        # down movement routine
        elif currentMove == 'd':
            row += 2
            if grid[row, col] != 2:
                grid[row, col] = 2
                grid[row - 1, col] = 1

            if uRestrict:
                uRestrict = False
                moveOptions.append('u')
            if (row + 2) == len(grid):
                dRestrict = True
                moveOptions.remove('d')


        ''' debug algorithm-watching code start'''
        # lets the user close the window if they request to, ends loop
        for event in pg.event.get():
            if event.type == pg.QUIT:
                done = True
        for i in range(len(grid)):
            for j in range(len(grid)):
                if grid[i, j] == 1 or grid [i,j] == 2:
                    pg.draw.line(screen, WHITE, [50*j, 24 + i*50], [50*(j+1), 24 + i*50], 50)
                else:
                    pg.draw.line(screen, BLACK, [50*j, 24 + i*50], [50*(j+1), 24 + i*50], 50)
                pg.draw.line(screen, RED, [50*col, 24 + row*50], [50*(col+1), 24 + row*50], 50)

        pg.display.update()
        ''' debug algorithm-watching code end'''
    
    # debug line: prints final nonzero count of grid
    # (of particular concern because loops throw off the expected count by one value each -- theoretically could end very early)
    print(np.count_nonzero(grid))
    return grid